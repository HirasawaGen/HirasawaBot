from functools import wraps
from itertools import chain, batched, takewhile
from pathlib import Path

from pypinyin import pinyin, Style
import yaml  # type: ignore
import openai
import time
import json
import random
import asyncio
from typing import Iterator


from ncatbot.plugin_system import (
    NcatBotPlugin,
    option,
    filter_registry,
    admin_filter,
    root_filter,
    command_registry,
    group_filter,
    on_notice,
    on_request,
)

from ncatbot.core import (
    GroupMessage,
    BaseMessageEvent,
    RequestEvent,
    NoticeEvent,
    Reply
)

from ncatbot.utils import get_log, run_coroutine
from ncatbot.plugin_system.builtin_plugin.unified_registry.command_system.utils.specs import CommandSpec

from .bot_utils import *
from .isaac_utis import *
from .ai_utils import HirasawaAI
from .falsifysignature import flatten_args, flatten_kwargs


__author__ = 'HirasawaGen'
__all__ = ['HirasawaBot']


class HirasawaBot(NcatBotPlugin):
    name = "HirasawaBot"
    author = __author__
    version = "0.0.1"
    description = "ÊàëÊòØÂπ≥Ê≤¢botÔºåCialloÔΩû(‚à†„Éªœâ< )‚åí‚òÜ"
    dependencies: dict = {}
    
    __matmul__ = lambda self, user_id: MyAt(qq=user_id)
        
    async def on_load(self) -> None:
        logger.info('on_load')
        config = self.config
        self.SPONSOR: Path = self.workspace / config['sponsor']
        self.JM_ROOT: Path = self.workspace / config['jm_root']
        self.ISAAC_ROOT: Path = self.workspace / config['isaac_root']
        self.ISAAC_COLLECTIBLES: Path = self.ISAAC_ROOT / 'items' / 'collectibles'
        self.ISAAC_TRINKETS: Path = self.ISAAC_ROOT / 'items' / 'trinkets'
        self.ISAAC_EID: Path = self.ISAAC_ROOT / 'eid'
        self.lang = 'zh_cn'  # ÊöÇÊó∂Á°¨ÁºñÁ†Å
        self.isaac_collectibles = load_eid('collectibles', self.ISAAC_ROOT, self.lang)
        self.isaac_trinkets = load_eid('trinkets', self.ISAAC_ROOT, self.lang)
        self.ADMIN_ID = config['admin_id']
        self.BOT_ID = config['bot_id']
        self.MAX_HISTORY = config['max_history']
        self.POP_FREQ = config['pop_freq']
        self.TEST_GROUP = config['test_group']
        self.promts = load_prompts(self.workspace / config['prompts_root'])
        ai_config = config['ai']
        provider = ai_config['providers'][ai_config['provider']]
        self._ai_client = HirasawaAI(
            base_url=provider['base_url'],
            api_key=provider['api_key'],
            model=provider['model'],
            frequency=ai_config['freq'],
        )
        self.pop_texts = [
            "ÊàëÊòØÂπ≥Ê≤¢botÔºåCialloÔΩû(‚à†„Éªœâ< )‚åí‚òÜ~",
            "ÊûÅÂìÅ‰∫∫Êú∫ÂÜíÊ≥°ÂÑø~",
            "ÊΩúÊ∞¥ÂÖöÂÅ∑Áúã‰∏≠‚Ä¶‚Ä¶",
        ]
        self.add_scheduled_task(
            self.daily_congraduate_talkative,
            'daily_task',
            '21:00',
        )
        return await super().on_load()
        # await self.api.post_private_msg(user_id=self.ADMIN_ID, text='Âπ≥Ê≤¢botÂ∑≤ÂêØÂä®ÔºÅ')
    
    # async def on_close(self):
    #     yaml.safe_dump(self.config, self.data_file.open('w', encoding='utf-8'))
    #     return await super().on_close()

    async def __pre_command__(self, event: BaseMessageEvent, spec: CommandSpec, *args, **kwargs) -> bool:
        logger.info(f"Executing command '{spec.name}' with args '{args}' and kwargs '{kwargs}'")
        req_length = len(spec.args_types) - len(spec.options)
        actual_length = len(args)
        if req_length != actual_length:
            if not isinstance(event, GroupMessage):
                return True
            await self.api.post_group_msg(
                group_id=event.group_id,
                at=event.sender.user_id,
                text=f' Êåá‰ª§ÂèÇÊï∞‰∏∫{req_length}Ôºå‰Ω†‰º†ÂÖ•‰∫Ü{actual_length}‰∏™ÂèÇÊï∞ÔºåÊó†Ê≥ïÊâßË°å„ÄÇ'
            )
            return False
        return True
            

    async def __post_command__(self, event: BaseMessageEvent, spec: CommandSpec, *args, **kwargs):
        logger.info(f"Command '{spec.name}' executed with args '{args}' and kwargs '{kwargs}'")

    @on_request
    async def on_request(self, event: RequestEvent):
        if not event.is_friend_request(): return
        await event.approve()
        self.api.send_private_text_sync(user_id=event.user_id, text='‰Ω†Â•ΩÔºåÊàëÊòØÂπ≥Ê≤¢botÔºåCialloÔΩû(‚à†„Éªœâ< )‚åí‚òÜ')
        self.log2admin(f"ÂêåÊÑè‰∫ÜÂ•ΩÂèãËØ∑Ê±ÇÔºö{event.user_id}")

    @on_notice
    async def on_notice(self, event: NoticeEvent):
        return
        if event.sub_type != 'poke': return
        group_id = str(event.group_id)
        user_id = str(event.user_id)
        target_id = str(event.target_id)
        if group_id == None or user_id == None: return
        if target_id not in self.config['pokes'].keys(): return
        logger.info(f'User {user_id} poked {target_id} in group {group_id}')
        self.api.post_group_array_msg_sync(
            group_id,
            self@user_id+self.config['pokes'][target_id],
        )
    
    
    
    @hirasawa  # type: ignore
    async def congradulate_talkative(self, event: MessageEventDuck):
        return self@event.user_id + 'ÊÅ≠Âñú‰Ω†ÔºÅ‰Ω†ÊòØ‰ªäÂ§©ÁöÑÈæôÁéãüêâüëëÔºÅÁªßÁª≠‰øùÊåÅÂ§öÊ∞¥Áæ§Âì¶ÔºÅ(¬¥‚àÄ`)~‚ô°'
   
    
    async def daily_congraduate_talkative(self):
        groups = await self.api.get_group_list(False)
        for group_id in groups:
            try:
                group_honor_info = await self.api.get_group_honor_info(group_id, 'all')
            except Exception as e:
                logger.error(type(e).__name__ + ': '+ str(e))
                continue
            talkative = group_honor_info.current_talkative
            await self.congradulate_talkative(
                MessageEventDuck('group', group_id, talkative.user_id)
            )
    
    
    @root_filter
    @group_filter
    @command_registry.command('talkative')
    @hirasawa
    async def test_talkative(self, event: GroupMessage):
        '''
        @Âá∫‰ªäÂ§©Êú¨Áæ§ÁöÑÈæôÁéãÔºåÂπ∂ÊÅ≠Âñú‰ªñ„ÄÇ
        Ê≥®ÔºöËØ•Êåá‰ª§Âè™Êúâbot‰∏ª‰∫∫ÂèØ‰ª•‰ΩøÁî®
        '''
        await self.congradulate_talkative(event)
            

    def repeat(self, event: GroupMessage):
        if event.sender.user_id == event.self_id: return
        history = self.analyse_history(event.group_id)
        if len(history) < 3: return
        if history[-1]['message'] != history[-2]['message']: return
        if history[-2]['message'] != history[-3]['message']: return
        yield event.raw_message
        yield False


    def formation(self, event: GroupMessage):
        if event.sender.user_id == event.self_id: return
        history = self.analyse_history(event.group_id)
        if len(history) < 4: return
        if not (history[-2]['message'] == history[-3]['message'] == history[-4]['message']): return
        if history[-1]['message'] != history[-2]['message']:
            yield Reply(event.message_id), '‰Ω†Ëøô‰∏™‰∫∫ÊÄé‰πàÈöè‰æøÊâì‰π±ÈòüÂΩ¢ÂïäÔºÅ'
            yield False
    
    def heyiwei(self, event: GroupMessage):
        if event.sender.user_id == event.self_id: return
        raw_text = event.raw_message.strip()
        if len(raw_text) < 3: return
        for word in batched(raw_text, 3):
            if pinyin(''.join(word), style=Style.NORMAL) != [['he'], ['yi'], ['wei']]: continue
            yield "‰ΩïÊÑèÂë≥Ôºü"
            yield False
            return
    
    def caicaibei(self, event: GroupMessage):
        if event.sender.user_id == event.self_id: return
        raw_text = event.raw_message.strip()
        if len(raw_text) != 3: return
        if raw_text[0] != raw_text[1]: return
        if pinyin(raw_text, Style.FIRST_LETTER, errors='replace') != [['c'], ['c'], ['b']]:
            return
        yield f'ËÄÅÁà∑Áà∑ÔºåÊàëÁªô‰Ω†{raw_text[-2]}{raw_text[-1]}Êù•ÂíØÔºÅ'
        yield False

    def group_pop(self, event: GroupMessage):
        if event.sender.user_id == event.self_id: return
        group_id = event.group_id
        pop_freq = self.POP_FREQ if group_id != self.TEST_GROUP else 8
        history = self.analyse_history(group_id)
        if len(history) <= pop_freq:
            return
        current_time = time.time()
        mimic_root = False
        for msg in history[-1:-1-pop_freq:-1]:
            if msg['sender_id'] == self.ADMIN_ID:
                mimic_root = True
            if msg['sender_id'] == event.self_id and current_time - msg['time'] < 10800:
                return
        if not mimic_root:
            pop_text = random.choice(self.pop_texts)
            yield pop_text
            yield False
            return
        # self.log2admin(f'Ê≠£Âú®Â∞ùËØïÂú®Áæ§{group_id}‰∏≠Èπ¶ÈπâÂ≠¶Ëàå')
        prompt = self.promts['group_pop'].render(
            history=history,
            ADMIN_ID=self.ADMIN_ID,
            BOT_ID=self.BOT_ID,
        )
        gen = self.ai_resp(map(lambda x: json.dumps(x, ensure_ascii=False), history), prompt=prompt)
        texts = [text for text in gen]
        if len(texts) != 1:
            self.log2admin('\n'.join(texts))
            return
        yield texts[0]
        yield False

    @group_filter
    @hirasawa
    async def on_group_message(self, event: GroupMessage) -> AsyncIterator[ItemType]:
        for item in takewhile(lambda x: x != False, chain(
            self.repeat(event),
            self.formation(event),
            self.heyiwei(event),
            self.caicaibei(event),
            self.group_pop(event),
        )):
            yield item

    def log2admin(self, msg: str):
        self.api.post_private_msg_sync(user_id=self.ADMIN_ID, text=msg)
    
    def ai_resp(self, messages: Iterator[str], prompt: str = ""):
        try:
            resp = self._ai_client << {
                "messages": messages,
                "prompt": prompt,
            }
            yield resp
        except AssertionError as e:
            if str(e).startswith("Too frequent requests"):
                yield "Ë∞ÉÁî®aiÊé•Âè£ÊòØËä±Èí±ÁöÑÂïäÔºÅÂπ≥Ê≤¢ÂéüÁöÑÈí±Â∞±‰∏çÊòØÈí±ÂêóÔºÅËØ∑‰∏çË¶ÅÈ¢ëÁπÅË∞ÉÁî®aiÊé•Âè£ÔºÅ"
                yield "Â∞ùËØïË∞ÉÁî®'/sponsor'ÂëΩ‰ª§ÔºåÊàñËÆ∏ÂèØ‰ª•ÁºìËß£‚Ä¶"
            elif str(e).startswith("Invalid response type"):
                yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
                yield f"ÈîôËØØÂéüÂõ†ÔºöAPIÂìçÂ∫îÁ±ªÂûãÈîôËØØ{str(e)}"
            elif str(e).startswith("Empty response"):
                yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
                yield f"ÈîôËØØÂéüÂõ†ÔºöÂêéÂè∞ÂìçÂ∫î‰∫ÜÁ©∫Â≠óÁ¨¶‰∏≤"
            else:
                yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
                yield f"ÂÖ∂‰ªñÂ§±Ë¥•ÂéüÂõ†ÔºöÂÖ∂‰ªñÊñ≠Ë®ÄÈîôËØØ{str(e)}"
        except openai.APIStatusError as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            if e.status_code == 429:
                yield "Âπ≥Ê≤¢ÂéüÁöÑapiË¥¶Âè∑Ê≤°Èí±‰∫ÜÂñµT_T"
                yield "ÊàñËÆ∏ÂèØ‰ª•Ë∞ÉÁî®/sponsorÂëΩ‰ª§ÁºìËß£Ë¥¢ÊîøÂç±Êú∫ÔºüÔºÅÔºÅ"
                return
            yield f"Â§±Ë¥•Áä∂ÊÄÅÁ†ÅÔºö'{e.status_code}: {e.message}'"
        except openai.APIResponseValidationError as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            yield "ÈîôËØØÂéüÂõ†ÔºöAPIÂìçÂ∫îÈ™åËØÅÈîôËØØ"
        except openai.APIConnectionError as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            yield "ÈîôËØØÂéüÂõ†ÔºöAPIËøûÊé•ÈîôËØØ"
        except openai.LengthFinishReasonError as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            yield "ÈîôËØØÂéüÂõ†ÔºöÂ§ß‰∫∫‰ª¨Ôºå‰∏ä‰∏ãÊñáÂ§™Èïø‰∫ÜT_T"
        except openai.ContentFilterFinishReasonError as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            yield "ÈîôËØØÂéüÂõ†ÔºöÂ§ß‰∫∫‰ª¨ÊòØ‰∏çÊòØËÅä‰∫Ü‰ªÄ‰πàÂùèÂùèÁöÑ‰∏úË•ø>_<"
        except openai.InvalidWebhookSignatureError as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            yield "ÈîôËØØÂéüÂõ†ÔºöWebhookÁ≠æÂêçÈîôËØØ"
        except Exception as e:
            yield "Â∞ëÂ•≥Ë∞ÉÁî®aiÊé•Âè£Â§±Ë¥•T_T"
            yield f"ÂÖ∂‰ªñÂ§±Ë¥•ÂéüÂõ†Ôºö{str(e)}"
    
    def analyse_history(self, group_id: str) -> list[dict]:
        messages_history = self.api.get_group_msg_history_sync(group_id=group_id, message_seq=0, number=self.MAX_HISTORY)
        history = []
        for message in messages_history:
            history.append({
                "message": message.raw_message,
                "sender_id": message.sender.user_id,
                "sender_name": message.sender.card if message.sender.card != '' else message.sender.nickname,
                "time": message.time,
            })
        return history
    
    @group_filter
    @command_registry.command('menu', aliases=['ËèúÂçï', 'help', 'Â∏ÆÂä©'])
    @hirasawa
    async def menu(self, event: GroupMessage):
        '''
        ËæìÂá∫Êåá‰ª§‰∏é‰ΩøÁî®ÊñπÂºè
        ‰∏∫Èò≤Ê≠¢ËøáÈïøÊ∂àÊÅØÂà∑È¢ëÔºåËØ•Êåá‰ª§Âè™‰ºöÈöèÊú∫ËæìÂá∫‰∏âÊù°Êåá‰ª§ÁöÑ‰ΩøÁî®ÊñπÂºè
        ‰æãÂ¶ÇÔºö
          /menu
        Ëã•ÈúÄË¶ÅÊü•ÁúãÊüêÊåá‰ª§ÁöÑÂÖ∑‰Ωì‰ΩøÁî®ÊñπÂºèÔºåËØ∑‰ΩøÁî®-hÂèÇÊï∞‰æãÂ¶Ç '/sponsor -h'
        '''
        commands = command_registry.get_all_commands()
        keys = commands.keys()
        user_id = event.sender.user_id
        user_role = get_role_level(user_id)
        # Êúâ‰∫õÊåá‰ª§ÊòØÁà∂Á±ªÊûÑÈÄ†ÁöÑÔºåÊàë‰πü‰∏çÁü•ÈÅì‰ªñÁöÑÊùÉÈôêÁ≠âÁ∫ßÔºåÁ¥¢ÊÄßÂΩì‰ΩúÊòØ 0
        keys = [k for k in keys if permissions.get(k[0], 0) >= user_role]
        keys = random.sample(keys, 3)
        ans = ['Â∑≤ËæìÂá∫Êª°Ë∂≥ÊÇ®ÊùÉÈôêÁöÑÈöèÊú∫‰∏âÊù°Êåá‰ª§ÔºÅ\nÂÜçÊ¨°ËæìÂÖ•ËØ•Êåá‰ª§Êü•ÁúãÂÖ∂‰ªñÈöèÊú∫Â•ΩÁé©Êåá‰ª§ÔºÅ']
        for key in keys:
            command = commands[key]
            desc = command.description if command.description != "" else f"ËØ•Êåá‰ª§ÊöÇÊó†ÊèèËø∞"
            info = f'/{key[0]}: \n{desc.strip()}'
            if len(command.aliases) > 0:
                info += '\nÂÖ∂‰ªñË∞ÉÁî®ÊñπÂºè: '
                info += ' '.join(f'/{alias}' for alias in command.aliases)
            ans.append(info)
            
        yield '\n\n# -------------------------- #\n'.join(ans)
     
    @group_filter
    @command_registry.command('sponsor', aliases=['ËµûÂä©'])
    @hirasawa
    async def sponsor(self, event: GroupMessage):
        '''
        ËæìÂá∫bot‰ΩúËÄÖÊÄßÊÑüÁÖßÁâá
        ‰æãÂ¶ÇÔºö/sponsor
        '''
        # ÂÖ∂ÂÆûËøôÈáåËæìÂá∫ÁöÑÊòØÊú¨‰∫∫ÂæÆ‰ø°Êî∂Ê¨æÁ†ÅÔºåÊàèËÄç‰∏Ä‰∏ãÂ§ßÂÆ∂
        yield self.SPONSOR
        yield "Â•Ω‰∫∫Ëµè‰ø∫ÂêÉÂè£È•≠ÂêßÔºÅ"
        
    @group_filter
    @command_registry.command('xdjx', aliases=['Á¨ëÁÇπËß£Êûê'])
    @hirasawa
    async def analyse_jokes(self, event: GroupMessage, num: int):
        '''
        ÂØπÊú¨Áæ§ÂâçnÊù°ËÅäÂ§©ËÆ∞ÂΩïÂÅöÁ¨ëÁÇπËß£Êûê
        ‰æãÂ¶ÇÔºö/xdjx 5
        '''
        if num > self.MAX_HISTORY // 2:
            yield f"Ë∞ÉÁî®aiÊé•Âè£ÊòØËä±Èí±ÁöÑÂïäÔºÅÂπ≥Ê≤¢ÂéüÁöÑÈí±Â∞±‰∏çÊòØÈí±ÂêóÔºÅËØ∑ÊääÂèÇÊï∞ÈôêÂà∂Âú®{self.MAX_HISTORY // 2}‰ª•ÂÜÖ"
            # yield self.SPONSOR
            return
        history = self.analyse_history(event.group_id)[:-1]
        history = history if len(history) <= self.MAX_HISTORY // 2 else history[-self.MAX_HISTORY // 2:]
        if len(history) < 0:
            yield "botÊöÇÊú™Êî∂Âà∞Êú¨Áæ§‰ªª‰ΩïÊ∂àÊÅØ"
        history = history if num > len(history) else history[-num:]
        prompt = self.promts['analyse_jokes'].render(
            history=history,
            ADMIN_ID=self.ADMIN_ID,
            BOT_ID=self.BOT_ID,
        )
        yield "Â∞ëÂ•≥Ëß£ÊûêÁ¨ëÁÇπ‰∏≠‚Ä¶"
        for msg in self.ai_resp(map(lambda x: json.dumps(x, ensure_ascii=False), history), prompt=prompt):
            yield msg
        
    @group_filter
    @command_registry.command('mimic', aliases=['Èπ¶ÈπâÂ≠¶Ëàå'])
    @hirasawa
    async def mimic(self, event: GroupMessage, mimic_user_id: str):
        '''
        Ê†πÊçÆÊú¨Áæ§ËÅäÂ§©ËÆ∞ÂΩïÊ®°‰ªøÊüê‰∏™Áî®Êà∑ËØ¥ËØù
        Â¶ÇÊûúËÅäÂ§©ËÆ∞ÂΩïÂ§™Áü≠ÊàñËÄÖËØ•Áî®Êà∑Áü≠Êó∂Èó¥ÂÜÖÊú™ÂèëË®ÄÂàô‰∏ç‰ºöÊ®°‰ªø
        ËæìÂÖ•qqÂè∑Ê®°‰ªøÁâπÂÆöÁî®Êà∑Ôºå‰æãÂ¶ÇÊ®°‰ªøbot‰ΩúËÄÖ/mimic 1294702887
        ËæìÂÖ•0Ê®°‰ªø‰Ω†ÔºåÂç≥/mimic 0
        ËæìÂÖ•Â∞è‰∫éÁ≠â‰∫é‰∏â‰ΩçÁöÑÊï∞Â≠óÊ®°‰ªø‰∏äÈù¢ÁöÑÁ¨¨n‰∏™‰∫∫ÔºåÂç≥/mimic 2Ê®°‰ªø‰∏ä‰∏ä‰∏Ä‰∏™‰∫∫
        ‰πüÂèØ‰ª•Áõ¥Êé•@Ôºå‰æãÂ¶ÇÔºö/mimic @Âπ≥Ê≤¢bot
        '''
        history = self.analyse_history(event.group_id)[:-1]
        history = history if len(history) <= self.MAX_HISTORY // 2 else history[-self.MAX_HISTORY // 2:]
        sender_id = event.sender.user_id
        if sender_id == 'invalid':
            yield f"Êó†ÊïàÁöÑQQÂè∑ÔºÅ"
            return
        mimic_user_id = get_user_info(mimic_user_id, history, sender_id)
        if len(history) < 20:
            yield f"botÊé•Êî∂Âà∞ÁöÑÊú¨Áæ§ËÅäÂ§©ËÆ∞ÂΩï‰ªÖÊúâ{len(history)}Êù°ÔºåËØ∑Á®çÂêéÂÜçËØï"
            return
        has_user_talked = False
        for msg in history:
            if msg['sender_id'] == mimic_user_id:
                has_user_talked = True
                break
        if not has_user_talked:
            yield f"ËØ•Áî®Êà∑{mimic_user_id}Âú®ÊúÄËøë{len(history)}Êù°ËÅäÂ§©ËÆ∞ÂΩï‰∏≠Êú™ÂèëË®ÄÔºåÊó†Ê≥ïÊ®°‰ªø"
            return
        prompt = self.promts['mimic'].render(
            mimic_user_id=mimic_user_id,
            history=history,
            ADMIN_ID=self.ADMIN_ID,
            BOT_ID=self.BOT_ID,
        )
        yield "Â∞ëÂ•≥Ê®°‰ªøÊùÇÈ±º‰∏≠‚Ä¶"
        # yield from self.ai_resp_old(map(lambda x: json.dumps(x, ensure_ascii=False), history), prompt=prompt)
        for msg in self.ai_resp(map(lambda x: json.dumps(x, ensure_ascii=False), history), prompt=prompt):
            yield msg

    @group_filter
    @command_registry.command('critic', aliases=['ËØÑ‰ª∑'])
    @hirasawa
    async def critic(self, event: GroupMessage, critic_user_id: str = ''):
        '''
        Áé©Áé©‰øÑÁΩóÊñØËΩÆÁõòËµå
        1/6Ê¶ÇÁéáÂò≤ËÆΩÊåñËã¶
        1/3Ê¶ÇÁéáÊ≠£Â∏∏ËØÑ‰ª∑
        1/2Ê¶ÇÁéáÊó†ËÑëÂêπÊçß
        ËæìÂÖ•qqÂè∑ËØÑ‰ª∑ÁâπÂÆöÁî®Êà∑Ôºå‰æãÂ¶ÇËØÑ‰ª∑bot‰ΩúËÄÖ/critic 1294702887
        ËæìÂÖ•0ËØÑ‰ª∑‰Ω†ÔºåÂç≥/critic 0
        ËæìÂÖ•Â∞è‰∫éÁ≠â‰∫é‰∏â‰ΩçÁöÑÊï∞Â≠óËØÑ‰ª∑‰∏äÈù¢ÁöÑÁ¨¨n‰∏™‰∫∫ÔºåÂç≥/critic 2ËØÑ‰ª∑‰∏ä‰∏ä‰∏Ä‰∏™‰∫∫
        ‰πüÂèØ‰ª•Áõ¥Êé•@Ôºå‰æãÂ¶ÇÔºö/critic @Âπ≥Ê≤¢bot
        '''
        history = self.analyse_history(event.group_id)[:-1]
        history = history if len(history) <= self.MAX_HISTORY // 2 else history[-self.MAX_HISTORY // 2:]
        sender_id = event.sender.user_id
        critic_user_id = get_user_info(critic_user_id, history, sender_id)
        # Â¶ÇÊûúËØÑ‰ª∑ÁöÑÊòØbot‰∏ª‰∫∫
        if critic_user_id == self.ADMIN_ID:
            yield "Á•ûÊú¨Êó†Áõ∏üòéüòéüòé"
            return
        if critic_user_id == 'invalid':
            yield "Êó†ÊïàÁöÑQQÂè∑ÔºÅ"
            return
        if len(history) < 20:
            yield f"botÊé•Êî∂Âà∞ÁöÑÊú¨Áæ§ËÅäÂ§©ËÆ∞ÂΩï‰ªÖÊúâ{len(history)}Êù°ÔºåËØ∑Á®çÂêéÂÜçËØï"
            return
        has_user_talked = False
        for msg in history:
            if msg['sender_id'] == critic_user_id:
                has_user_talked = True
                break
        if not has_user_talked:
            yield f"ËØ•Áî®Êà∑{critic_user_id}Âú®ÊúÄËøë{len(history)}Êù°ËÅäÂ§©ËÆ∞ÂΩï‰∏≠Êú™ÂèëË®ÄÔºåÊó†Ê≥ïËØÑ‰ª∑"
            return
        choice = random.randint(1, 6)  # ÈöèÊú∫ÁîüÊàê1Âà∞6‰πãÈó¥ÁöÑÊï¥Êï∞
        mode = ''
        if choice == 1:
            yield self@critic_user_id + "Âæà‰∏çÂπ∏Ôºå‰Ω†ÊäΩ‰∏≠‰∫ÜÊÅ∂ËØÑÔºÅ"
            mode = 'ËøõË°åÂ∞ΩÂèØËÉΩÁäÄÂà©ÁöÑÊåñËã¶‰∏éËÆ•ËÆΩ'
        elif choice <= 3:
            yield self@critic_user_id + "Ê≤°ÊäΩ‰∏≠Â•ΩËØÑ‰πüÊ≤°ÊäΩ‰∏≠ÊÅ∂ËØÑÔºåbotÂ∞ÜÂØπ‰Ω†ÂÆ¢ËßÇËØÑ‰ª∑"
            mode = 'Ê≠£Â∏∏ÁöÑËØÑ‰ª∑'
        else:
            yield self@critic_user_id + "ÊÅ≠Âñú‰Ω†Ôºå‰Ω†ÊäΩ‰∏≠‰∫ÜÂ•ΩËØÑÔºÅ"
            mode = 'Â∞ΩÂèØËÉΩÂ¥áÈ´òÁöÑË§íÂ•ñ‰∏éÂêπÊçß'
        prompt = self.promts['critic'].render(
            critic_user_id=critic_user_id,
            history=history,
            mode=mode,
            ADMIN_ID=self.ADMIN_ID,
            BOT_ID=self.BOT_ID,
        )
        yield "Â∞ëÂ•≥ËØÑ‰ª∑ÊùÇÈ±º‰∏≠‚Ä¶"
        for msg in self.ai_resp(map(lambda x: json.dumps(x, ensure_ascii=False), history), prompt=prompt):
            yield msg
        
    @group_filter
    @command_registry.command('isaac', aliases=['‰ª•ÊííÁöÑÁªìÂêà', '‰ª•Êíí'])
    # @hirasawa_option.no_desc('‰∏çËæìÂá∫ÈÅìÂÖ∑/È•∞ÂìÅÁöÑÊèèËø∞')
    @hirasawa
    async def isaac(self, event: GroupMessage, arg: str, **options):
        '''
        ËæìÂÖ•„Ää‰ª•ÊííÁöÑÁªìÂêàÔºöÂøèÊÇî„Äã‰∏≠ÁöÑÈÅìÂÖ∑ÁºñÂè∑ÊàñÈ•∞ÂìÅÁºñÂè∑ÔºåÊàñËÄÖÁõ¥Êé•ËæìÂÖ•ÂêçÁß∞ÔºåËæìÂá∫ÂØπÂ∫îÁöÑÂõæÁâá‰ª•ÂèäEIDÊèèËø∞„ÄÇ
        Âä†ÂÖ•-nÂèÇÊï∞Â∞Ü‰∏çËæìÂá∫ÈÅìÂÖ∑/È•∞ÂìÅÁöÑÊèèËø∞
        ÔºàËæìÂÖ•ÂêçÁß∞Ê£ÄÁ¥¢ÊöÇÊó∂‰ªÖÊîØÊåÅ‰∏≠ÊñáÔºåÂπ∂‰∏îÂ¶ÇÊûúÊèê‰æõÁöÑËØçÊ±áÂ§™Â∞ëÔºåÂàô‰ºö‰ΩøÁî®ÊúÄÊó©ÊêúÁ¥¢Âà∞ÁöÑÈÅìÂÖ∑/È•∞ÂìÅÔºâ
        ‰æãÂ¶ÇÔºö
          - /isaac C118
          - /isaac Â¶àÂ¶àÁöÑËèúÂàÄ
          - /isaac -n Â¶àÂ¶àÁöÑËèúÂàÄ
        '''
        no_desc = options.get('no_desc', False)
        if arg[0].upper() == 'C':
            item_id = arg[1:]
            if not item_id.isdigit():
                yield "Êó†ÊïàÁöÑÁºñÂè∑ÔºÅ"
                return
            info = self.isaac_collectibles.get(int(item_id), None)
            if info is None:
                yield "Êú™ÊâæÂà∞ËØ•ÈÅìÂÖ∑ÔºÅ"
                return
            yield eid_description('collectibles', self.ISAAC_ROOT, info, no_desc)
        elif arg[0].upper() == 'T':
            item_id = arg[1:]
            if not item_id.isdigit():
                yield "Êó†ÊïàÁöÑÁºñÂè∑ÔºÅ"
                return
            info = self.isaac_trinkets.get(int(item_id), None)
            if info is None:
                yield "Êú™ÊâæÂà∞ËØ•È•∞ÂìÅÔºÅ"
                return
            yield eid_description('trinkets', self.ISAAC_ROOT, info, no_desc)
        else:  # ‰∏≠ÊñáÊ£ÄÁ¥¢
            found = False
            for info in self.isaac_collectibles.values():
                name = info['name']
                if arg not in name: continue
                found = True
                yield eid_description('collectibles', self.ISAAC_ROOT, info, no_desc)
                return
            for info in self.isaac_trinkets.values():
                name = info['name']
                if arg not in name: continue
                found = True
                yield eid_description('trinkets', self.ISAAC_ROOT, info, no_desc)
                return
            if not found:
                yield "Êú™ÊâæÂà∞ËØ•ÈÅìÂÖ∑/È•∞ÂìÅÔºÅ"
    
    @group_filter
    @command_registry.command('kick')
    @hirasawa
    async def kick(self, event: GroupMessage):
        '''
        ‰ΩøÁî®ËØ•Êåá‰ª§‰ΩøbotÈÄÄÂá∫Êú¨Áæ§
        ‰ΩøÁî®Á¨¨‰∏âÊñπbotÊ°ÜÊû∂,Â¶ÇÊûúÊú∫Âô®‰∫∫Ë¢´Ë∏¢ÁöÑËØùÂèØËÉΩÂºïËµ∑È£éÊéß
        ÊâÄ‰ª•ÂΩìÁÆ°ÁêÜÂëòÊÉ≥Ë¶ÅË∏¢botÔºå‰∏çË¶ÅÁõ¥Êé•Ë∏¢
        ËØ∑‰ΩøÁî®‚Äò/kick‚ÄôÂëΩ‰ª§ÔºåÔºàÊó†ÈúÄ@Êú∫Âô®‰∫∫Ôºâ
        Èô§Áæ§ËÅäÁÆ°ÁêÜÂëò‰∏ébot‰∏ª‰∫∫Â§ñÔºåÂÖ∂‰ªñ‰∫∫Êó†Ê≥ï‰ΩøÁî®ËØ•ÂëΩ‰ª§
        '''
        group_id = event.group_id
        sender = event.sender
        user_id = sender.user_id
        role = sender.role
        if user_id == self.ADMIN_ID or role == 'owner' or role == 'admin':
            yield "Ê≠£Âú®ÈÄÄÂá∫Áæ§ËÅä..."
            self.api.set_group_leave_sync(group_id)
            return
        yield "Âè™ÊúâÁæ§ÁÆ°ÁêÜÂëò‰∏ébot‰∏ª‰∫∫ÂèØ‰ª•‰ΩøÁî®ËØ•ÂëΩ‰ª§ÔºÅ"
        
    @root_filter
    @group_filter
    @command_registry.command('temp')
    @hirasawa
    async def temp(self, event: GroupMessage, qq_id:str, text: str):
        '''
        ÁªôÊú¨Áæ§Êüê‰∏™Áæ§ÂèãÂèëÈÄÅ‰∏¥Êó∂‰ºöËØù
        Âè™ÊúâbotÁÆ°ÁêÜÂëòÂèØ‰ª•‰ΩøÁî®
        '''
        self.api.send_private_text_sync(qq_id, text)
        yield "Â∑≤ÂèëÈÄÅ‰∏¥Êó∂‰ºöËØùÔºÅ"
        return
    
    @root_filter
    @group_filter
    @command_registry.command('sleep')
    @hirasawa
    async def sleep(self, event: GroupMessage, seconds: int):
        logger.info(f'sleep command received')
        yield 'sleeping'
        await asyncio.sleep(seconds)
        yield 'wake up'
    
    @group_filter
    @command_registry.command('close', aliases=['shutdown', 'ÂÖ≥Êú∫'])
    @hirasawa
    async def close(self, event: GroupMessage):
        '''
        ÂÖ≥Èó≠botÔºå‰ΩøÂÖ∂‰∏çÂÜçÂìçÂ∫î‰ªª‰ΩïÊ∂àÊÅØ
        Âè™ÊúâbotÁÆ°ÁêÜÂëòÂèØ‰ª•‰ΩøÁî®
        '''
        yield "Ê≠£Âú®ÂÖ≥Èó≠bot..."
        self.api.bot_exit_sync()
        return

    @group_filter
    @command_registry.command('who_spy', aliases=['Ë∞ÅÊòØÂçßÂ∫ï'])
    @hirasawa
    async def who_spy(self, event: GroupMessage):
        '''
        ÊöÇÊú™ÂÆûÁé∞
        '''
        ...
        
    @root_filter
    @command_registry.command('echo')
    @hirasawa
    async def echo(self, event: GroupMessage, *args: str):
        '''
        foo
        '''
        yield '\n'.join(args)
    
    @group_filter
    @command_registry.command('pokes', aliases=['Êà≥‰∏ÄÊà≥'])
    @hirasawa
    async def pokes(self, event: GroupMessage, *texts: str):
        '''
        ÂÆöÂà∂Âåñ‰Ω†ÁöÑÊà≥‰∏ÄÊà≥ÂõûÂ§ç
        ‰æãÂ¶ÇÔºö
          - /pokes Âà´Êà≥‰ªñ‰∫ÜÔºÅ
        ÂΩì‰Ω†Âú®Áæ§ÈáåË¢´Êüê‰∫∫Êà≥Êó∂ÔºåbotÂ∞±‰ºöÂõûÂ§çÔºö
          - @Êüê‰∫∫ Âà´Êà≥‰ªñ‰∫ÜÔºÅ
        Ê≥®ÔºöËÆæÁΩÆË∑®Áæ§ÊúâÊïà
        '''
        text = ' '.join(texts)
        self.config['pokes'][event.sender.user_id] = text
        yield f'Â∑≤ËÆæÁΩÆÊÇ®ÁöÑÂÆöÂà∂ÂåñÊà≥‰∏ÄÊà≥‰∏∫Ôºö\n{text}'
        
        
        
        